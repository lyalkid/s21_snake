Path: brick_game/tetris/src/TGM3Randomizer.c
Contents:
/*
 * @author Azamat G.
 * @date 12.08.2025.
 * @details
 *
 */

#include "../../utils/defines.h"
#include "../../utils/utilities.h"
#include "../game_api/game_api.h"
#include "../inc/tetris.h"
int piece_str_to_type(const char *piece) {
  if (strcmp(piece, "I") == 0) return I;
  if (strcmp(piece, "J") == 0) return J;
  if (strcmp(piece, "L") == 0) return L;
  if (strcmp(piece, "O") == 0) return O;
  if (strcmp(piece, "S") == 0) return S;
  if (strcmp(piece, "T") == 0) return T;
  if (strcmp(piece, "Z") == 0) return Z;
  return -1;
}

int contains(const char *arr[], int size, const char *value) {
  for (int i = 0; i < size; i++) {
    if (strcmp(arr[i], value) == 0) return 1;
  }
  return 0;
}

int index_of(const char *arr[], int size, const char *value) {
  for (int i = 0; i < size; i++) {
    if (strcmp(arr[i], value) == 0) return i;
  }
  return -1;
}

void init_randomizer(TGM3Randomizer *r) {
  const char *pieces[7] = {"I", "J", "L", "O", "S", "T", "Z"};
  memcpy(r->pieces, pieces, sizeof(pieces));

  for (int i = 0; i < 35; i++) {
    r->pool[i] = r->pieces[i % 7];
  }

  const char *firstOptions[4] = {"I", "J", "L", "T"};
  const char *firstPiece = firstOptions[rand() % 4];

  r->history[0] = "S";
  r->history[1] = "Z";
  r->history[2] = "S";
  r->history[3] = firstPiece;

  r->order[0] = firstPiece;
  r->order_size = 1;
  get_data()->current_tetraMino.type = piece_str_to_type(firstPiece);
  // get_tetramino_instance()->next_type = piece_str_to_type(next_piece(r));
}

const char *next_piece(TGM3Randomizer *r) {
  int roll, idx;
  const char *piece = NULL;

  for (roll = 0; roll < 6; roll++) {
    idx = rand() % 35;
    piece = r->pool[idx];

    if (!contains(r->history, 4, piece) || roll == 5) {
      break;
    }
    if (r->order_size > 0) {
      r->pool[idx] = r->order[0];
    }
  }

  int pos = index_of(r->order, r->order_size, piece);
  if (pos != -1) {
    for (int i = pos; i < r->order_size - 1; i++) {
      r->order[i] = r->order[i + 1];
    }
    r->order_size--;
  }

  r->order[r->order_size++] = piece;

  int indexInPool = index_of(r->pool, 35, piece);
  if (indexInPool != -1) {
    r->pool[indexInPool] = r->order[0];
  }

  for (int i = 0; i < 3; i++) {
    r->history[i] = r->history[i + 1];
  }
  r->history[3] = piece;

  return piece;
}
void next_tetramino(TGM3Randomizer *r) {
  Tetramino *tetramino = &get_data()->current_tetraMino;
  tetramino->type = tetramino->next_type;
  tetramino->rotate = COMPLETE;
  tetramino->center_x = 0;
  tetramino->center_y = 0;
  null_array(tetramino->tmp_current_figure_on_field, HEIGHT, WIDTH);
  generateTetraminoShape(tetramino->coordinates, tetramino->rotate,
                         tetramino->type);
  tetramino->next_type = piece_str_to_type(next_piece(r));
}
--------------------------------------------------

Path: brick_game/tetris/src/storage.c
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */
#include <stdio.h>

#include "../inc/tetris.h"
int get_highScore() { return 0; }
void write_high_score(int h_score) {
  h_score = 1;
  printf("%d", h_score);
}
--------------------------------------------------

Path: brick_game/tetris/src/tetramino.c
Contents:
/*
 * @author Azamat G.
 * @date 14.08.2025.
 * @details
 *
 */

#include "../inc/tetris.h"

void print_tetramino(Tetramino tetramino) {
  printf("centr_x:%d\ncentr_y:%d\n", tetramino.center_x, tetramino.center_y);
}

Tetramino init_empty_tetraMino() {
  Tetramino tetraMino = {0};
  tetraMino.type = 0;

  tetraMino.next_type = 1;

  tetraMino.rotate = 0;
  tetraMino.center_x = 0;
  tetraMino.center_y = 0;
  for (int i = 0; i < 8; i++) {
    tetraMino.coordinates[i] = 0;
  }

  tetraMino.tmp_current_figure_on_field = malloc_array(HEIGHT, WIDTH);

  init_randomizer(&tetraMino.r);
  return tetraMino;
}

// Tetramino *get_tetramino_instance() {
//   static Tetramino *t;
//   if (t == NULL) {
//     t = malloc(sizeof(Tetramino));
//     // *t = init_empty_tetraMino();
//
//     t->type = 0;
//     t->next_type = 1;
//
//     t->rotate = 0;
//     t->center_x = 0;
//     t->center_y = 0;
//     for (int i = 0; i < 8; i++) {
//       t->coordinates[i] = 0;
//     }
//
//     t->tmp_current_figure_on_field = malloc_array(HEIGHT, WIDTH);
//
//     init_randomizer(&t->r);
//   }
//   return t;
// }

void placeTetraminoInArray(Tetramino tetraMino, int **next) {
  for (int i = 0; i < HEIGHT; i++) {
    for (int j = 0; j < WIDTH; j++) {
      next[i][j] = 0;
    }
  }
  for (int i = 0; i < 8; i += 2) {
    int x = tetraMino.coordinates[i] + tetraMino.center_x;
    int y = tetraMino.coordinates[i + 1] + tetraMino.center_y;
    if ((x >= 0 && x < WIDTH) && (y >= 0 && y < HEIGHT))
      next[y][x] = tetraMino.type;
  }
}

void setCoordinates(int *coordinates, const int *values) {
  for (int i = 0; i < 8; i++) {
    coordinates[i] = values[i];
  }
}

void generateTetraminoShape(int coordinates[], int rotate, int type) {
  if (type >= T && type <= L) {
    generateShapeTJL(coordinates, rotate, type);
  } else if (type >= I && type <= Z) {
    generateShapeSZorI(coordinates, rotate, type);
  } else if (type == O) {
    int coord[] = {4, 0, 5, 0, 4, 1, 5, 1};
    setCoordinates(coordinates, coord);
  } else {
    int coord[] = {0, 0, 0, 0, 0, 0, 0, 0};
    setCoordinates(coordinates, coord);
  }
}

void generateShapeSZorI(int coordinates[], int rotate, int type) {
  if (rotate % 2 == 1 && type == Z) {
    int coord[] = {4, 2, 4, 1, 5, 1, 5, 0};
    setCoordinates(coordinates, coord);

    /* ..#
     * .##
     * .#.
     *
     * */
  } else if (type == Z) {
    int coord[] = {3, 0, 4, 0, 4, 1, 5, 1};
    setCoordinates(coordinates, coord);

    /* ...
     * ##.
     * .##
     *
     * */
  } else if (rotate % 2 == 1 && type == S) {
    int coord[] = {4, 0, 4, 1, 5, 1, 5, 2};
    setCoordinates(coordinates, coord);

    /* .#.
     * .##
     * ..#
     *
     * */
  } else if (type == S) {
    int coord[] = {4, 0, 5, 0, 3, 1, 4, 1};
    setCoordinates(coordinates, coord);

    /* ...
     * .##
     * ##.
     *
     * */
  } else if (rotate % 2 == 1 && type == I) {
    int coord[] = {5, 2, 5, 1, 5, 0, 5, 3};
    setCoordinates(coordinates, coord);

    /* ..#.
     * ..#.
     * ..#.
     * ..#.
     *
     * */
  } else if (type == I) {
    int coord[] = {3, 0, 4, 0, 5, 0, 6, 0};
    setCoordinates(coordinates, coord);

    /* ....
     * ....
     * ####
     * ....
     *
     * */
  }
}

void generateShapeTJL(int coordinates[], int rotate, int type) {
  // TODO если это Т то поднять наверх

  // TODO ПРОВЕРИТЬ на коректность в соответвии со специф tetris rotate system
  if (type == T && rotate == STRAIGHT) {
    int coord[] = {3, 0, 4, 0, 5, 0, 4, 1};
    setCoordinates(coordinates, coord);

    /* ...
     * ###
     * .#.
     *
     * */
  } else if (type == T && rotate == RIGHT) {
    int coord[] = {3, 0, 4, 0, 4, -1, 4, 1};
    setCoordinates(coordinates, coord);

    /* .#.
     * ##.
     * .#.
     *
     * */
  } else if (type == T && rotate == COMPLETE) {
    int coord[] = {3, 0, 4, 0, 5, 0, 4, -1};

    setCoordinates(coordinates, coord);

    /* .#.
     * ###
     * ...
     *
     * */
  } else if (type == T && rotate == REFLEX) {
    int coord[] = {5, 0, 4, 0, 4, -1, 4, 1};
    setCoordinates(coordinates, coord);

    /* .#.
     * .##
     * .#.
     *
     * */
  } else if (type == L && rotate == COMPLETE) {
    int coord[] = {3, 1, 4, 1, 5, 1, 5, 0};
    setCoordinates(coordinates, coord);
    /* ..#
     * ###
     * ...
     *
     * */
  } else if (type == L && rotate == RIGHT) {
    int coord[] = {4, 0, 4, 1, 4, 2, 5, 2};
    setCoordinates(coordinates, coord);
    /* .#.
     * .#.
     * .##
     *
     * */
  } else if (type == L && rotate == STRAIGHT) {
    int coord[] = {3, 1, 4, 1, 5, 1, 3, 2};
    setCoordinates(coordinates, coord);
    /*
     * ...
     * ###
     * #..
     *
     * */
  } else if (type == L && rotate == REFLEX) {
    int coord[] = {4, 0, 4, 1, 4, 2, 3, 0};
    setCoordinates(coordinates, coord);
    /* ##.
     * .#.
     * .#.
     *
     * */
  } else if (type == J && rotate == COMPLETE) {
    int coord[] = {3, 1, 4, 1, 5, 1, 3, 0};
    setCoordinates(coordinates, coord);
    /*
     * #..
     * ###
     * ...
     *
     * */
  } else if (type == J && rotate == RIGHT) {
    int coord[] = {4, 0, 4, 1, 4, 2, 5, 0};
    setCoordinates(coordinates, coord);

    /* .##
     * .#.
     * .#.
     *
     * */
  } else if (type == J && rotate == STRAIGHT) {
    int coord[] = {3, 1, 4, 1, 5, 1, 5, 2};
    setCoordinates(coordinates, coord);
    /*
     * ...
     * ###
     * ..#
     *
     * */
  } else if (type == J && rotate == REFLEX) {
    int coord[] = {4, 0, 4, 1, 4, 2, 3, 2};
    setCoordinates(coordinates, coord);

    /* .#.
     * .#.
     * ##.
     *
     * */
  }
}

--------------------------------------------------

Path: brick_game/tetris/src/game_rules.c
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */

#include "../inc/tetris.h"
int calc_score(int lines) {
  int res = 0;
  if (lines != 0) {
    switch (lines) {
      case 1:
        res = 100;
        break;
      case 2:
        res = 300;
        break;
      case 3:
        res = 700;
        break;
      default:
        res = 1500;
        break;
    }
  }
  return res;
}
int calc_level(int current_score) {
  int res = current_score / 600;
  return res > 10 ? 10 : res;
}
--------------------------------------------------

Path: brick_game/tetris/src/game_state_management.c
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */
#include "../inc/tetris.h"

int mergeFigureIntoField(int** next, int** field) {
  int is_all_ok_val = canMergeFigures(field, next);
  if (is_all_ok_val) {
    for (int i = 0; i < HEIGHT; i++) {
      for (int j = 0; j < WIDTH; j++) {
        int n_tmp = next[i][j];
        int f_tmp = field[i][j];
        int res = n_tmp + f_tmp;
        field[i][j] = res;
      }
    }
  }
  return is_all_ok_val;
}
int check_collision(Tetramino tetraMino, int** field) {
  int is_all_ok_val = MY_OK;
  for (int i = 0; i < 8; i += 2) {
    int x = tetraMino.coordinates[i] + tetraMino.center_x;
    int y = tetraMino.coordinates[i + 1] + tetraMino.center_y;
    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) {
      is_all_ok_val = ERROR;
      break;
    }
  }
  if (is_all_ok_val == MY_OK) {
    int** tmp_next = malloc_array(HEIGHT, WIDTH);
    placeTetraminoInArray(tetraMino, tmp_next);
    is_all_ok_val = canMergeFigures(field, tmp_next);
    free_array(tmp_next, HEIGHT);
  }
  return is_all_ok_val;
}
int canMergeFigures(int** field, int** next) {
  int** tmp_next = malloc_array(HEIGHT, WIDTH);

  int** tmp_field = malloc_array(HEIGHT, WIDTH);
  bin_array(next, tmp_next, HEIGHT, WIDTH);

  bin_array(field, tmp_field, HEIGHT, WIDTH);
  int is_all_ok_val = MY_OK;

  for (int i = 0; i < HEIGHT; i++) {
    for (int j = 0; j < WIDTH; j++) {
      int n_tmp = tmp_next[i][j];
      int f_tmp = tmp_field[i][j];
      int res = n_tmp + f_tmp;
      if (res > 1) {
        is_all_ok_val = ERROR;
        break;
      }
    }
    if (is_all_ok_val == ERROR) break;
  }
  free_array(tmp_field, HEIGHT);
  free_array(tmp_next, HEIGHT);

  return is_all_ok_val;
}

--------------------------------------------------

Path: brick_game/tetris/src/timer.c
Contents:
/*
 * @author Azamat G.
 * @date 29.08.2025.
 * @details
 *
 */
#include "../inc/timer.h"

int is_time_to_shift(time_val before, time_val after, long timer) {
  long res = (after.tv_sec * 1000000 + after.tv_usec) -
             (before.tv_sec * 1000000 + before.tv_usec);

  return res > timer;
}
void countTime(Shift_timer* timer) {
  get_time(&timer->after);

  if (is_time_to_shift(timer->before, timer->after, timer->delay_to_shift)) {
    timer->time_to_shift = true;
  }
}

Shift_timer init_shift_timer() {
  Shift_timer timer = {0};
  get_time(&timer.before);
  get_time(&timer.after);
  timer.delay_to_shift = TIME;
  timer.time_to_shift = false;
  return timer;
}

int get_time(time_val* tp) {
  if (!tp) return -1;

  // clock() возвращает время с начала выполнения программы в тактах
  clock_t t = clock();
  double seconds = (double)t / CLOCKS_PER_SEC;

  tp->tv_sec = (long)seconds;
  tp->tv_usec = (long)((seconds - tp->tv_sec) * 1000000);
  return 0;
}

// Shift_timer* get_shift_timer_instance() {
//   static Shift_timer* sh_timer;
//   if (sh_timer == NULL) {
//     sh_timer = malloc(sizeof(Shift_timer));
//
//     gettimeofday(&sh_timer->before, NULL);
//     gettimeofday(&sh_timer->after, NULL);
//     sh_timer->delay_to_shift = TIME * pow(0.9,
//     get_game_info_instance()->level);
//     ;
//     sh_timer->time_to_shift = false;
//   }
//   return sh_timer;
// }
--------------------------------------------------

Path: brick_game/tetris/src/tetramino_movement.c
Contents:
/*
 * @author Azamat G.
 * @date 14.08.2025.
 * @details
 *
 */

#include "../inc/tetramino_movement.h"

int canMoveTetramino(Tetramino tetraMino, int **field, UserAction_t key) {
  int **next = malloc_array(HEIGHT, WIDTH);
  int **tmp_next = malloc_array(HEIGHT, WIDTH);

  int **tmp_field = malloc_array(HEIGHT, WIDTH);
  placeTetraminoInArray(tetraMino, next);
  moveTetramino(&tetraMino, key);
  placeTetraminoInArray(tetraMino, next);

  bin_array(next, tmp_next, HEIGHT, WIDTH);

  bin_array(field, tmp_field, HEIGHT, WIDTH);
  int is_all_ok_val = canMergeFigures(tmp_field, tmp_next);
  free_array(tmp_next, HEIGHT);
  free_array(tmp_field, HEIGHT);
  free_array(next, HEIGHT);

  return is_all_ok_val;
}

int is_rotate_possible(Tetramino tetraMino, int rotate) {
  int possible = 1;
  tetraMino.rotate = rotate;
  generateTetraminoShape(tetraMino.coordinates, tetraMino.rotate,
                         tetraMino.type);
  for (int i = 0; i < 8; i += 2) {
    int x = tetraMino.coordinates[i] + tetraMino.center_x;
    int y = tetraMino.coordinates[i + 1] + tetraMino.center_y;
    if (x < 0 || x >= WIDTH || y >= HEIGHT || y < 0) {
      possible = 0;
      break;
    }
  }
  return possible;
}

int isHorizontalMoveOrRotate(UserAction_t userAction) {
  int res = MY_OK;
  if (!(userAction == Left || userAction == Right || userAction == Action))
    res = ERROR;
  return res;
}

int isDownMove(UserAction_t userAction) {
  int res = MY_OK;
  if (userAction != Down) {
    res = ERROR;
  }
  return res;
}

void moveTetramino(Tetramino *tetraMino, UserAction_t key) {
  // TODO уменьшить размер строк

  int min_x =
      get_min(get_min(tetraMino->coordinates[0], tetraMino->coordinates[2]),
              get_min(tetraMino->coordinates[4], tetraMino->coordinates[6])) +
      tetraMino->center_x;

  int max_x =
      get_max(get_max(tetraMino->coordinates[0], tetraMino->coordinates[2]),
              get_max(tetraMino->coordinates[4], tetraMino->coordinates[6])) +
      tetraMino->center_x;
  switch (key) {
    case Left:
      if ((min_x - 1) >= 0) tetraMino->center_x -= 1;
      break;

    case Right:
      if ((max_x + 1 < WIDTH)) tetraMino->center_x += 1;
      break;
    case Action:
      rotate_TetraMino(tetraMino);
      break;
    case Down:
      move_down_tetraMino(tetraMino);
      break;
    default:
      break;
  }
}

void move_down_tetraMino(Tetramino *tetraMino) { tetraMino->center_y += 1; }

void move_up_tetraMino(Tetramino *tetraMino) {
  if (tetraMino->center_y >= HEIGHT - 1) tetraMino->center_y -= 1;
}

void rotate_TetraMino(Tetramino *tetraMino) {
  int rotate = (tetraMino->rotate + 1) % 4;

  if (is_rotate_possible(*tetraMino, rotate)) {
    tetraMino->rotate = rotate;
    generateTetraminoShape(tetraMino->coordinates, tetraMino->rotate,
                           tetraMino->type);
  }
}

--------------------------------------------------

Path: brick_game/tetris/src/field_mechanics.c
Contents:
/*
 * @author Azamat G.
 * @date 14.08.2025.
 * @details
 *
 */

#include "../inc/tetris.h"

int removeFullLines(int** field, int rows, int cols) {
  int count = 0;
  int full_scan = 0;
  while (full_scan != 2) {
    int flag = 1;
    for (int i = rows - 1; i >= 0; i--) {
      int destroy = isLineFull(field[i], cols);
      if (destroy == YES) {
        removeLine(field, cols, i);
        count++;
        flag = 0;
      }
    }
    if (flag == 1) full_scan++;
  }
  return count;
}
int isLineFull(const int a[], int size) {
  int sum = 0;
  for (int i = 0; i < size; i++) {
    if (a[i] != 0) sum++;
  }
  return sum == size ? YES : NO;
}
void removeLine(int** field, int cols, int row_not) {
  for (int i = 0; i < cols; i++) {
    field[row_not][i] = 0;
  }
  for (int j = 0; j < cols; j++) {
    for (int i = row_not; i > 0; i--) {
      //        int tmp_a = field[i][j];
      int tmp_b = field[i - 1][j];
      field[i][j] = tmp_b;
    }
  }
}

--------------------------------------------------

Path: brick_game/tetris/inc/tetramino_movement.h
Contents:
/*
 * @author Azamat G.
 * @date 14.08.2025.
 * @details
 *
 */

#ifndef TETRAMINO_MOVEMENT_H
#define TETRAMINO_MOVEMENT_H
#include "tetris.h"

/**
 * @brief Проверяет возможность движения фигуры.
 *
 * @param tetraMino Фигура.
 * @param field Игровое поле.
 * @param key Направление (Left/Right/Action).
 * @return 1 если возможно, иначе 0.
 */
int canMoveTetramino(Tetramino tetraMino, int **field, UserAction_t key);

/**
 * @brief Проверяет возможность поворота.
 *
 * @param tetraMino Фигура.
 * @param rotate Угол поворота (0-3).
 * @return 1 если возможно, иначе 0.
 */
int is_rotate_possible(Tetramino tetraMino, int rotate);
/**
 * @brief Двигает фигуру.
 *
 * @param tetraMino Указатель на фигуру.
 * @param key Направление (Left/Right/Action).
 */
// Аналогично для:
void moveTetramino(Tetramino *tetraMino, UserAction_t key);
void move_down_tetraMino(Tetramino *tetraMino);
void move_up_tetraMino(Tetramino *tetraMino);
void rotate_TetraMino(Tetramino *tetraMino);
/**
 * @brief Проверяет, является ли действие движением.
 *
 * @param userAction Действие.
 * @return 1 если да, иначе 0.
 */
int isHorizontalMoveOrRotate(UserAction_t userAction);
/**
 * @brief Проверяет, является ли действие движением вниз.
 *
 * @param userAction Действие.
 * @return 1 если нет, 0 если Down.
 */
int isDownMove(UserAction_t userAction);

#endif  // TETRAMINO_MOVEMENT_H

--------------------------------------------------

Path: brick_game/tetris/inc/tetris.h
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */

#ifndef TETRIS_H
#define TETRIS_H
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "../../brick_game.h"
#include "../../utils/defines.h"
#include "../../utils/utilities.h"

enum answer { YES, NO };

/** Статусы функций. */
enum status { ERROR, MY_OK };

/** Типы фигур. */
enum figures { T = 1, J, L, I, S, Z, O };

/** Углы поворота фигур. */
enum degrees { COMPLETE, RIGHT, STRAIGHT, REFLEX };

/**
 * @brief Генератор фигур в стиле TGM3.
 *
 * @field pieces Доступные фигуры.
 * @field pool Пул фигур (35 элементов).
 * @field order Порядок выдачи фигур.
 * @field order_size Текущий размер order.
 * @field history История последних фигур (4 элемента).
 */
typedef struct {
    int order_size;
    const char *history[4];
    const char *pieces[7];
    const char *order[7];
    const char *pool[35];
} TGM3Randomizer;

/**
 * @brief Структура тетрамино.
 *
 * @field type Текущий тип фигуры.
 * @field next_type Следующий тип.
 * @field rotate Угол поворота.
 * @field center_x X-центр фигуры.
 * @field center_y Y-центр фигуры.
 * @field coordinates Координаты блоков (относительно центра).
 * @field tmp_current_figure_on_field Временное поле для отрисовки.
 */

typedef struct {
    int type;
    int next_type;
    int rotate;
    int center_x;
    int center_y;
    int coordinates[8];
    int **tmp_current_figure_on_field;
    TGM3Randomizer r;
} Tetramino;

/**
 * @brief Создает пустую фигуру.
 *
 * @return Инициализированная структура Tetramino.
 */
Tetramino init_empty_tetraMino();

// Tetramino *get_tetramino_instance();

int piece_str_to_type(const char *piece);

/**
 * @brief Инициализация генератора TGM3
 *
 * @param r Указатель на структуру генератора
 */
void init_randomizer(TGM3Randomizer *r);

/**
 * @brief Получить следующую фигуру
 *
 * @param r Указатель на структуру генератора
 * @return const char* Символ фигуры ("I", "J", "L", "O", "S", "T", "Z")
 */
const char *next_piece(TGM3Randomizer *r);

/**
 * @brief Проверяет, содержится ли элемент в массиве
 *
 * @param arr Массив строк
 * @param size Размер массива
 * @param value Строка для поиска
 * @return 1 — найдено, 0 — нет
 */
int contains(const char *arr[], int size, const char *value);

/**
 * @brief Ищет индекс элемента в массиве
 *
 * @param arr Массив строк
 * @param size Размер массива
 * @param value Строка для поиска
 * @return Индекс или -1, если не найдено
 */
int index_of(const char *arr[], int size, const char *value);

void next_tetramino(TGM3Randomizer *r);

void print_tetramino(Tetramino tetramino);

/**
 * @brief Преобразует фигуру в 2D-массив.
 *
 * @param tetraMino Фигура.
 * @param next Целевой массив.
 */
void placeTetraminoInArray(Tetramino tetraMino, int **next);

/**
 * @brief Копирует координаты фигуры.
 *
 * @param coordinates Целевой массив.
 * @param values Исходные координаты.
 */
void setCoordinates(int *coordinates, const int *values);

/**
 * @brief Генерирует координаты фигуры по типу и углу.
 *
 * @param coordinates Целевой массив.
 * @param rotate Угол поворота.
 * @param type Тип фигуры (T, J, L, I, S, Z, O).
 */
void generateTetraminoShape(int coordinates[], int rotate, int type);

/**
 * @brief Генерирует координаты фигуры по типу и углу.
 *
 * @param coordinates Целевой массив.
 * @param rotate Угол поворота.
 * @param type Тип фигуры (T, J, L, I, S, Z, O).
 */
void generateShapeSZorI(int coordinates[], int rotate, int type);

/**
 * @brief Генерирует координаты фигуры по типу и углу.
 *
 * @param coordinates Целевой массив.
 * @param rotate Угол поворота.
 * @param type Тип фигуры (T, J, L, I, S, Z, O).
 */
void generateShapeTJL(int coordinates[], int rotate, int type);

/**
 * @brief Создает новую фигуру.
 *
 * @param tetraMino Указатель на фигуру.
 *
 * @details Использует TGM3Randomizer для генерации.
 */
void spawnNextTetramino(Tetramino *tetraMino);

/**
 * @brief Сканирует поле на заполненные строки.
 *
 * @param field Игровое поле.
 * @param rows Число строк.
 * @param cols Число столбцов.
 * @return Количество удаленных строк.
 *
 * @details Удаляет строки и сдвигает поле вниз.
 */
int removeFullLines(int **field, int rows, int cols);

/**
 * @brief Проверяет, заполнена ли строка.
 *
 * @param a Строка поля.
 * @param size Длина строки.
 * @return 1 (YES) если заполнена, иначе 0.
 */
int isLineFull(const int a[], int size);

/**
 * @brief Удаляет строку и сдвигает поле.
 *
 * @param field Игровое поле.
 * @param cols Число столбцов.
 * @param row_not Индекс удаляемой строки.
 */
void removeLine(int **field, int cols, int row_not);

/**
 * @brief Вычисляет очки за удаленные строки.
 *
 * @param lines Число строк.
 * @return Количество очков.
 */
int calc_score(int lines);

/**
 * @brief Вычисляет текущий уровень игры на основе счета.
 *
 * @param current_score Текущий счет игрока.
 * @return Текущий уровень (0-10).
 *
 * @details Формула: level = current_score / 600, максимум 10.
 */
int calc_level(int current_score);

GameInfo_t init_empty_gameInfo(void);

/**
 * @brief Объединяет поле с фигурой.
 *
 * @param next Массив фигуры.
 * @param field Игровое поле.
 * @return 1 (MY_OK) если объединение успешно, 0 (ERROR) при коллизии.
 */
int mergeFigureIntoField(int **next, int **field);

/**
 * @brief Проверяет коллизию фигуры с игровым полем.
 *
 * @param tetraMino Фигура для проверки.
 * @param field Игровое поле.
 * @return 1 (MY_OK) если коллизий нет, 0 (ERROR) при коллизии.
 */
int check_collision(Tetramino tetraMino, int **field);

/**
 * @brief Проверяет коллизию поля и фигуры.
 *
 * @param field Игровое поле.
 * @param next Фигура.
 * @return 1 если коллизии нет, иначе 0.
 */
int canMergeFigures(int **field, int **next);

/**
 * @brief Получает рекорд из файла.
 *
 * @return Текущий рекорд (0 если файл недоступен).
 *
 * @note Файл: "highscore.txt" в рабочей директории.
 */
int get_highScore();

/**
 * @brief Записывает новый рекорд в файл.
 *
 * @param h_score Новое значение рекорда.
 *
 * @note Файл: "highscore.txt" в рабочей директории.
 */
void write_high_score(int h_score);

#endif  // TETRIS_H

--------------------------------------------------

Path: brick_game/tetris/inc/timer.h
Contents:
/*
 * @author Azamat G.
 * @date 29.08.2025.
 * @details
 *
 */

#ifndef TIMER_H
#define TIMER_H
#include <math.h>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#define TIME 2000000  // 2 seconds

typedef struct {
  long tv_sec;
  long tv_usec;
} time_val;

typedef struct {
  time_val before;
  time_val after;
  long delay_to_shift;  // через какое время делать shift
  bool time_to_shift;  // показывает нужно ли делать shift
} Shift_timer;

Shift_timer init_shift_timer();
// Shift_timer *get_shift_timer_instance();

int is_time_to_shift(time_val before, time_val after, long timer);

void countTime(Shift_timer *timer);

void init_timer(Shift_timer *timer);
#include <stdint.h>

int get_time(time_val *tp);

#endif  // TIMER_H

--------------------------------------------------

Path: brick_game/tetris/game_api/game_api.h
Contents:
//
// Created by Azamat G. on 08.08.2025.
//

#ifndef GAME_API_H
#define GAME_API_H

#include <stdbool.h>
#include <stdlib.h>
#include "../../brick_game.h"
#include "../inc/tetramino_movement.h"
#include "../inc/timer.h"
typedef enum {
    STATE_START,
    STATE_SPAWN,
    STATE_MOVEMENT ,
    STATE_ATTACH,
    STATE_SHIFT,
    STATE_PAUSE,
    STATE_GAME_OVER,
    STATE_EXIT
}Tetris_state;

/**
 * @brief Структура для хранения игровой информации
 * @field currenState - текущее состоянии
 * @field shift_timer - таймер для управления скоростью
 * @field current_tetraMino - текущая фигура
 * @field current_game_info - текущее состояние игры
 */
typedef struct {
    UserAction_t current_action;
    Tetris_state current_state;
    Shift_timer shift_timer;
    Tetramino current_tetraMino;
    GameInfo_t current_game_info;
}TetrisData_t;

TetrisData_t *get_data(void);
TetrisData_t init_empty_data(void);

const char* stateToString(Tetris_state s);
void fsm(void);
void reset_game();
void free_game() ;
Tetris_state* get_state() ;
void userInput(UserAction_t action, bool hold);
void onMoving(UserAction_t action);

void onStart(TetrisData_t* data);
int onDownMoving(UserAction_t action) ;
int onSpawn(Tetramino *tetraMino, GameInfo_t *game_info);
int onShifting(void);
GameInfo_t updateCurrentState();


#endif //GAME_API_H

--------------------------------------------------

Path: brick_game/tetris/game_api/game_api.c
Contents:
/*
 * @author Azamat G.
 * @date 12.08.2025.
 * @details
 *
 */
#include "game_api.h"

#include "../inc/timer.h"

// typedef enum {
//     Start,
//     Pause,
//     Terminate,
//     Left, movement
//     Right, movement
//     Up, movement
//     Down, movement
//     Action, movement
//   } UserAction_t;
TetrisData_t *get_data(void) {
  static TetrisData_t *data;
  if (data == NULL) {
    data = (TetrisData_t *)malloc(sizeof(TetrisData_t));
    *data = init_empty_data();
  }
  return data;
}

TetrisData_t init_empty_data(void) {
  TetrisData_t data = {0};
  data.current_action = NONE_ACTION;
  data.current_state = STATE_START;
  data.shift_timer = init_shift_timer();
  data.current_tetraMino = init_empty_tetraMino();
  data.current_game_info = init_empty_gameInfo();
  return data;
}

Tetris_state *get_state() {
  static Tetris_state *state;
  if (state == NULL) {
    state = malloc(sizeof(Tetris_state));
  }
  return state;
}

const char *stateToString(Tetris_state s) {
  switch (s) {
    case STATE_START:
      return "start    ";
    case STATE_SPAWN:
      return "spawn    ";
    case STATE_MOVEMENT:
      return "movement ";
    case STATE_ATTACH:
      return "attaching";
    case STATE_SHIFT:
      return "shift    ";
    case STATE_PAUSE:
      return "pause    ";
    case STATE_GAME_OVER:
      return "game_over";
    case STATE_EXIT:
      return "exit     ";
    default:
      return "unknown  ";
  }
}

void userInput(UserAction_t action, bool hold) {
  TetrisData_t *data = get_data();

  switch (action) {
    case Start:
      break;
    case Pause:
      data->current_game_info.pause = 1;
      break;
    case Terminate:
      data->current_state = STATE_EXIT;
      fsm();
      break;
    // case Up:
    // break;
    case Left:
    case Right:
    case Down:
    case Action:
      fsm();
      data->current_action = NONE_ACTION;
      break;
  }

  if (hold) {
    hold = true;
  } else {
    hold = false;
  }
}

void fsm() {
  TetrisData_t *data = get_data();

  int is_game_over = MY_OK;
  switch (data->current_state) {
    case STATE_START:
      if (data->current_game_info.field != NULL &&
          data->current_tetraMino.tmp_current_figure_on_field != NULL) {
        reset_game();
      }
      data->current_state = STATE_SPAWN;
      // data->current_action = NONE_ACTION;
      break;
    case STATE_SPAWN:
      is_game_over =
          onSpawn(&data->current_tetraMino, &data->current_game_info);
      if (!is_game_over) {
        data->current_state = STATE_GAME_OVER;
      } else {
        // spawn figure
        data->current_state = STATE_MOVEMENT;
      }
      break;
    case STATE_MOVEMENT:
      int shift = MY_OK;
      if (isHorizontalMoveOrRotate(data->current_action) == MY_OK) {
        onMoving(data->current_action);
      } else if (isDownMove(data->current_action)) {
        shift = onDownMoving(data->current_action);
      }
      // else if (data->current_action == Pause) {
      //     data->currentState = STATE_PAUSE;
      // }
      if (shift == MY_OK && data->shift_timer.time_to_shift == true) {
        data->current_state = STATE_SHIFT;
      }
      break;

    case STATE_SHIFT:
      data->current_action = Down;
      onDownMoving(data->current_action);
      data->shift_timer.time_to_shift = false;
      get_time(&data->shift_timer.before);

      if (data->current_state != STATE_SPAWN) {
        data->current_state = STATE_MOVEMENT;
      }
      data->current_action = NONE_ACTION;
      break;
    case STATE_PAUSE:

      break;

    case STATE_GAME_OVER:
      break;
    case STATE_EXIT:
      data->current_action = Terminate;
      free_game();
      exit(EXIT_SUCCESS);
      break;
      // case movement:
      //     if (isHorizontalMoveOrRotate(current_action) == MY_OK) {
      //         onMoving(current_action);
      //     } else if (isDownMove(current_action)) {
      //         onDownMoving(current_action);
      //     }
      //     break;
      // case shift:
      //     if (timer->time_to_shift == true) {
      //         onDownMoving(Down);
      //         timer->time_to_shift = false;
      //         get_time(&timer->before, NULL);
      //     }
      //     break;
      //
      //
      //
      // case pause:
      //     while (getch() != 'p') {
      //         timeout(10);
      //     }
      //     *state = start;
      //     break;
      // case game_over:
      //     while (getch() != 'p') {
      //         timeout(1000);
      //     }
      //     break;
      // default:
      //     break;
      //     *state = shift;
  }
}

void reset_game() {
  TetrisData_t *data = get_data();
  *data = init_empty_data();
}

void free_game() {
  TetrisData_t *data = get_data();
  data->current_state = STATE_EXIT;
  free_array(data->current_game_info.field, HEIGHT);
  free_array(data->current_game_info.next, NEXT_FIELD);
  free_array(data->current_tetraMino.tmp_current_figure_on_field, HEIGHT);

  // free(data);
}

void onMoving(UserAction_t action) {
  Tetramino *tetramino = &get_data()->current_tetraMino;
  GameInfo_t *game_info = &get_data()->current_game_info;
  if (canMoveTetramino(*tetramino, game_info->field, action) == MY_OK) {
    moveTetramino(tetramino, action);
    placeTetraminoInArray(*tetramino, tetramino->tmp_current_figure_on_field);
  }
}

int onDownMoving(UserAction_t action) {
  Tetramino *tetramino = &get_data()->current_tetraMino;
  GameInfo_t *game_info = &get_data()->current_game_info;
  moveTetramino(tetramino, action);
  if (check_collision(*tetramino, game_info->field) == ERROR) {
    tetramino->center_y--;
    // attaching
    placeTetraminoInArray(*tetramino, tetramino->tmp_current_figure_on_field);
    mergeFigureIntoField(tetramino->tmp_current_figure_on_field,
                         game_info->field);

    // calc score
    game_info->score +=
        calc_score(removeFullLines(game_info->field, HEIGHT, WIDTH));
    game_info->level = game_info->score / 600;
    game_info->speed = TIME * pow(0.9, game_info->level);
    get_data()->shift_timer.delay_to_shift = (long)game_info->speed;
    // spawn

    get_data()->current_state = STATE_SPAWN;
    // next_tetramino(&tetramino->r);
    // int is_all_ok_val = onSpawn(*tetramino, *game_info);

    // if (is_all_ok_val!= MY_OK) {
    //     State *state = get_state();
    //      *state = game_over;
    //
    // }

    return ERROR;
  }

  placeTetraminoInArray(*tetramino, tetramino->tmp_current_figure_on_field);
  return MY_OK;
}

int onSpawn(Tetramino *tetraMino, GameInfo_t *game_info) {
  int is_all_ok_val = MY_OK;

  next_tetramino(&tetraMino->r);

  placeTetraminoInArray(*tetraMino, tetraMino->tmp_current_figure_on_field);

  is_all_ok_val =
      canMergeFigures(game_info->field, tetraMino->tmp_current_figure_on_field);

  return is_all_ok_val;
}

GameInfo_t updateCurrentState() {
  fsm();
  return (get_data()->current_game_info);
}

// void fsm(UserAction_t action) {
//     State *state = get_state();
//     switch (*state) {
//         case shift:
//             if (timer->time_to_shift == true) {
//                 onDownMoving(Down);
//                 timer->time_to_shift = false;
//                 get_time(&timer->before, NULL);
//             }
//             break;
//         case movement:
//             if (isHorizontalMoveOrRotate(action) == MY_OK) {
//                 onMoving(action);
//             } else if (isDownMove(action)) {
//                 onDownMoving(action);
//             }
//             break;
//         case pause:
//             break;
//         case game_over:
//             break;
//         default:
//             break;
//             *state = shift;
//     }
//
//
//     if (*state == attaching) {
//         *state = shift;
//     }
//     if (*state == shift) {
//
//     }
// }

--------------------------------------------------

