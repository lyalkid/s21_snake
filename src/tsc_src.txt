Path: ../tsc/src/gui/cli/menu.c
Contents:
/*
 * @author Azamat G.
 * @date 09.08.2025.
 * @details
 *
 */

#include <curses.h>

#include "cli.h"

int handle_menu() {
  const char* list[ITEMS] = {"exit", "tetris", "snake", "cars"};

  init_menu();
  int highlight = 0;
  int choice = 0;
  int c = 0;
  while (1) {
    print_menu(get_game_wins()->menu_win, highlight, list);
    c = wgetch(get_game_wins()->menu_win);
    if (c == KEY_UP || c == CONTROL_UP) {
      highlight--;
      if (highlight < 0) highlight = ITEMS - 1;
    } else if (c == KEY_DOWN || c == CONTROL_DOWN) {
      highlight++;
      if (highlight >= ITEMS) highlight = 0;

    } else if (c == CONTROL_NEXT) {
      choice = highlight;
    } else {
      refresh();
    }
    // Если сделан выбор (Enter)
    if (c == CONTROL_NEXT) {
      break;
    }
  }
  return choice;
}

void init_menu() {
  WINDOW* title_win = get_game_wins()->title_win;
  WINDOW* menu_win = get_game_wins()->menu_win;
  WINDOW* info_win = get_game_wins()->info_win;
  keypad(menu_win, TRUE);
  set_title(title_win, "BRICKGAME");
  refresh();
  box(menu_win, 0, 0);
  box(title_win, 0, 0);
  box(info_win, 0, 0);
  wrefresh(menu_win);
  wrefresh(title_win);
  wrefresh(info_win);
}

void set_title(WINDOW* title_win, char* title) {
  mvwprintw(title_win, 1, 8, "%s", title);
}

void print_menu(WINDOW* menu_win, int highlight, const char** choices) {
  int x = 2, y = 2;
  box(menu_win, 0, 0);

  for (int i = 0; i < ITEMS; ++i) {
    if (highlight == i) {
      wattron(menu_win, A_REVERSE);
      mvwprintw(menu_win, y, x, "%s", choices[i]);
      wattroff(menu_win, A_REVERSE);
    } else {
      mvwprintw(menu_win, y, x, "%s", choices[i]);
    }
    y++;
  }
  wrefresh(menu_win);
}

--------------------------------------------------

Path: ../tsc/src/gui/cli/cli.c
Contents:
//
// Created by Azamat G. on 08.08.2025.
//
#include "cli.h"

// #include <curses.h>
#include <stdio.h>
void init_nc() {
  initscr();
  cbreak();
  noecho();
  //  int h = 0, w = 0;

  init_colors();

  nodelay(stdscr, TRUE);
  keypad(stdscr, TRUE);
  curs_set(0);
  timeout(1000);
}

/**
 * @brief Двигает фигуру влево.
 */
Tetris_wins_t init_tetris_wins() {
  Tetris_wins_t views = {};
  getmaxyx(stdscr, views.yMax, views.xMax);
  // delwin(views.game_win);
  return views;
}
void set_tetris_wins(Tetris_wins_t* views) {
  views->game_win = newwin(FIELD_Y, FIELD_X, 0, 0);
  views->info_win = newwin(INFO_Y - 2, INFO_X, 0, FIELD_X);
  views->next_win = newwin(NEXT_Y + 2, NEXT_X, INFO_Y - 2, FIELD_X);
  refresh();
  box(views->game_win, 0, 0);
  box(views->info_win, 0, 0);
  box(views->next_win, 0, 0);
  wrefresh(views->game_win);
  wrefresh(views->info_win);
  wrefresh(views->next_win);
  refresh();
}

void init_colors() {
  start_color();
  init_pair(9, COLOR_BLACK, COLOR_BLACK);
  init_pair(1, COLOR_BLACK, COLOR_RED);
  init_pair(2, COLOR_BLACK, COLOR_CYAN);
  init_pair(3, COLOR_BLACK, COLOR_BLUE);
  init_pair(4, COLOR_BLACK, COLOR_YELLOW);
  init_pair(5, COLOR_BLACK, COLOR_WHITE);
  init_pair(6, COLOR_BLACK, COLOR_GREEN);
  init_pair(7, COLOR_BLACK, COLOR_MAGENTA);
}

void terminate_ncurses() {
  clearok(stdscr, TRUE);  // Устанавливаем флаг перерисовки экрана
  clear();  // Очищаем экран
  refresh();
  refresh();
  endwin();
}

Tetris_wins_t* get_tetris_wins() {
  static Tetris_wins_t* views;
  if (views == NULL) {
    views = malloc(sizeof(Tetris_wins_t));
  }
  return views;
}
Game_wins_t* get_game_wins() {
  static Game_wins_t* game_wins;
  if (game_wins == NULL) {
    game_wins = malloc(sizeof(Game_wins_t));
    game_wins->title_win = newwin(3, 25, 1, 1);
    game_wins->menu_win = newwin(15, 25, 4, 1);
    game_wins->info_win = newwin(15, 25, 4, 26);
  }
  return game_wins;
}
void cleanup_game_wins(Game_wins_t* game_wins) {
  if (game_wins != NULL) {
    if (game_wins->title_win != NULL) {
      delwin(game_wins->title_win);
    }
    if (game_wins->menu_win != NULL) {
      delwin(game_wins->menu_win);
    }
    if (game_wins->info_win != NULL) {
      delwin(game_wins->info_win);
    }

    free(game_wins);
  }
}

--------------------------------------------------

Path: ../tsc/src/gui/cli/cli.h
Contents:
//
// Created by Azamat G. on 08.08.2025.
//


#ifndef CLI_H
#define CLI_H
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <ncurses.h>
#include "../../brick_game/brick_game.h"
#include "render/render.h"
typedef struct {
    int yMax;
    int xMax;
    WINDOW* game_win;
    WINDOW* info_win;
    WINDOW* next_win;
} Tetris_wins_t;

typedef struct {
    WINDOW* title_win;
    WINDOW* menu_win;
    WINDOW* info_win;
}Game_wins_t;


void init_nc();
void set_tetris_wins(Tetris_wins_t* views);
void init_colors();
void terminate_ncurses();

int handle_menu() ;
void print_menu(WINDOW *menu_win, int highlight, const char **choices);
void init_menu();
void set_title(WINDOW* title_win, char* title);
Game_wins_t* get_game_wins() ;
void cleanup_game_wins(Game_wins_t* game_wins);
Tetris_wins_t init_tetris_wins();
Tetris_wins_t* get_tetris_wins();



#endif //CLI_H

--------------------------------------------------

Path: ../tsc/src/gui/cli/render/render.h
Contents:
/*
* @author Azamat G. 
* @date 14.08.2025.
* @details
*
*/

#ifndef RENDER_H
#define RENDER_H
#include "../cli.h"

void render_tetris_game_win(WINDOW* win, int** field, int** current_figure_on_field) ;
#endif //RENDER_H

--------------------------------------------------

Path: ../tsc/src/gui/cli/render/render_tetris.c
Contents:
/*
 * @author Azamat G.
 * @date 14.08.2025.
 * @details
 *
 */
#include "render.h"

void render_tetris_game_win(WINDOW* win, int** field,
                            int** current_figure_on_field) {
  werase(win);

  for (int i = 0; i < HEIGHT; i++) {
    for (int j = 0; j < WIDTH; j++) {
      int res = field[i][j] + current_figure_on_field[i][j];
      if ((res != 0 && field[i][j] == 0) || field[i][j] != 0) {
        wattron(win, COLOR_PAIR(res));

        mvwprintw(win, i + 1, j * scale_field + 1, "  ");

        wattroff(win, COLOR_PAIR(res));

      } else {
        mvwprintw(win, i + 1, j * scale_field + 1, "[]");
      }
    }
  }
  box(win, 0, 0);
  wrefresh(win);
  refresh();
}
--------------------------------------------------

Path: ../tsc/src/.vscode/launch.json
Contents:
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": []
}
--------------------------------------------------

Path: ../tsc/src/.vscode/settings.json
Contents:
{
    "cmake.sourceDirectory": "/wsl$/Ubuntu/home/gulsara/code/tsc/src"
}
--------------------------------------------------

Path: ../tsc/src/game_api/game_api.h
Contents:
//
// Created by Azamat G. on 08.08.2025.
//

#ifndef GAME_API_H
#define GAME_API_H
#include <stdbool.h>
#include <stdlib.h>
#include "../brick_game/brick_game.h"



void userInput(UserAction_t action, bool hold);

GameInfo_t updateCurrentState();

void tetris_userInput(UserAction_t action, bool hold);

GameInfo_t tetris_updateCurrentState();

typedef enum { GAME_TETRIS, GAME_SNAKE } GameType;

GameType *getCurrentGameType() {
    static GameType *currentGame;
    if (currentGame == NULL) { currentGame = (GameType *) malloc(sizeof(GameType)); }
    return currentGame;
}
void selectGame( GameType game);

#endif //GAME_API_H

--------------------------------------------------

Path: ../tsc/src/game_api/game_api.c
Contents:
/*
* @author Azamat G. 
* @date 12.08.2025.
* @details
*
*/
#include "game_api.h"
//
// void selectGame( GameType game) {
//     GameType* currentGame = getCurrentGameType();
//     *currentGame = game;
// }
//
// void userInput(UserAction_t action, bool hold) {
//     const GameType* currentGame = getCurrentGameType();
//     if (*currentGame == GAME_TETRIS) tetris_userInput(action, hold);
//     // else if (*currentGame == GAME_SNAKE) snake_userInput(action, hold);
// }
//
// GameInfo_t updateCurrentState() {
//     const GameType* currentGame = getCurrentGameType();
//     if (*currentGame == GAME_TETRIS) return tetris_updateCurrentState();
//     // else return snake_updateCurrentState();
// }
// void tetris_userInput(UserAction_t action, bool hold){}
//
// GameInfo_t tetris_updateCurrentState(){}
--------------------------------------------------

Path: ../tsc/src/brick_game/brick_game.h
Contents:
//
// Created by Azamat G. on 08.08.2025.
//

#ifndef BRICK_GAME_H
#define BRICK_GAME_H
#include <stdlib.h>

#include "tetris/tetris_engine/tetris_engine.h"

typedef enum {
  Start,
  Pause,
  Terminate,
  Left,
  Right,
  Up,
  Down,
  Action,
} UserAction_t;

typedef struct {
  int score;
  int high_score;
  int level;
  int speed;
  int pause;
  int** field;
  int** next;
} GameInfo_t;

#endif  // BRICK_GAME_H

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/tetris_engine.h
Contents:
/*
 * @author Azamat G.
 * @date 14.08.2025.
 * @details
 *
 */

#ifndef TETRIS_ENGINE_H
#define TETRIS_ENGINE_H
#include <stdio.h>
#include <stdlib.h>

#include "../../brick_game.h"
#include "inc/TGM3Randomizer.h"
#include "inc/defines.h"
#include "inc/field_mechanics.h"
#include "inc/game_rules.h"
#include "inc/game_state_management.h"
#include "inc/storage.h"
#include "inc/tetramino.h"
#include "inc/tetramino_movement.h"
#include "inc/utilities.h"
#endif  // TETRIS_ENGINE_H

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/src/TGM3Randomizer.c
Contents:
/*
 * @author Azamat G.
 * @date 12.08.2025.
 * @details
 *
 */

#include "../inc/TGM3Randomizer.h"
int contains(const char *arr[], int size, const char *value) {
  for (int i = 0; i < size; i++) {
    if (strcmp(arr[i], value) == 0) return 1;
  }
  return 0;
}

int index_of(const char *arr[], int size, const char *value) {
  for (int i = 0; i < size; i++) {
    if (strcmp(arr[i], value) == 0) return i;
  }
  return -1;
}

void init_randomizer(TGM3Randomizer *r) {
  const char *pieces[7] = {"I", "J", "L", "O", "S", "T", "Z"};
  memcpy(r->pieces, pieces, sizeof(pieces));

  for (int i = 0; i < 35; i++) {
    r->pool[i] = r->pieces[i % 7];
  }

  const char *firstOptions[4] = {"I", "J", "L", "T"};
  const char *firstPiece = firstOptions[rand() % 4];

  r->history[0] = "S";
  r->history[1] = "Z";
  r->history[2] = "S";
  r->history[3] = firstPiece;

  r->order[0] = firstPiece;
  r->order_size = 1;
}

const char *next_piece(TGM3Randomizer *r) {
  int roll, idx;
  const char *piece = NULL;

  for (roll = 0; roll < 6; roll++) {
    idx = rand() % 35;
    piece = r->pool[idx];

    if (!contains(r->history, 4, piece) || roll == 5) {
      break;
    }
    if (r->order_size > 0) {
      r->pool[idx] = r->order[0];
    }
  }

  int pos = index_of(r->order, r->order_size, piece);
  if (pos != -1) {
    for (int i = pos; i < r->order_size - 1; i++) {
      r->order[i] = r->order[i + 1];
    }
    r->order_size--;
  }

  r->order[r->order_size++] = piece;

  int indexInPool = index_of(r->pool, 35, piece);
  if (indexInPool != -1) {
    r->pool[indexInPool] = r->order[0];
  }

  for (int i = 0; i < 3; i++) {
    r->history[i] = r->history[i + 1];
  }
  r->history[3] = piece;

  return piece;
}

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/src/storage.c
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */
#include "../inc/storage.h"
int get_highScore() { return 0; }
void write_high_score(int h_score) {}
--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/src/tetramino.c
Contents:
/*
 * @author Azamat G.
 * @date 14.08.2025.
 * @details
 *
 */
#include "../inc/tetramino.h"

Tetramino init_empty_tetraMino() {
  Tetramino tetraMino = (Tetramino){0};
  tetraMino.type = 0;
  tetraMino.next_type = 0;

  tetraMino.rotate = 0;
  tetraMino.center_x = 0;
  tetraMino.center_y = 0;
  for (int i = 0; i < 8; i++) {
    tetraMino.coordinates[i] = 0;
  }

  tetraMino.tmp_current_figure_on_field = malloc_array(HEIGHT, WIDTH);

  return tetraMino;
}
void tetra_to_array(Tetramino tetraMino, int** next) {
  for (int i = 0; i < HEIGHT; i++) {
    for (int j = 0; j < WIDTH; j++) {
      next[i][j] = 0;
    }
  }
  for (int i = 0; i < 8; i += 2) {
    int x = tetraMino.coordinates[i] + tetraMino.center_x;
    int y = tetraMino.coordinates[i + 1] + tetraMino.center_y;
    next[y][x] = tetraMino.type;
  }
}
void setCoordinates(int* coordinates, const int* values) {
  for (int i = 0; i < 8; i++) {
    coordinates[i] = values[i];
  }
}
void get_TetraMino(int coordinates[], int rotate, int type) {
  if (type >= T && type <= L) {
    get_tetra_four(coordinates, rotate, type);
  } else if (type >= I && type <= Z) {
    get_tetra_two(coordinates, rotate, type);
  } else if (type == O) {
    int coord[] = {4, 0, 5, 0, 4, 1, 5, 1};
    setCoordinates(coordinates, coord);
  } else {
    int coord[] = {0, 0, 0, 0, 0, 0, 0, 0};
    setCoordinates(coordinates, coord);
  }
}

void get_tetra_two(int coordinates[], int rotate, int type) {
  if (rotate % 2 == 1 && type == Z) {
    int coord[] = {4, 2, 4, 1, 5, 1, 5, 0};
    setCoordinates(coordinates, coord);

    /* ..#
     * .##
     * .#.
     *
     * */
  } else if (type == Z) {
    int coord[] = {3, 0, 4, 0, 4, 1, 5, 1};
    setCoordinates(coordinates, coord);

    /* ...
     * ##.
     * .##
     *
     * */
  } else if (rotate % 2 == 1 && type == S) {
    int coord[] = {4, 0, 4, 1, 5, 1, 5, 2};
    setCoordinates(coordinates, coord);

    /* .#.
     * .##
     * ..#
     *
     * */

  } else if (type == S) {
    int coord[] = {4, 0, 5, 0, 3, 1, 4, 1};
    setCoordinates(coordinates, coord);

    /* ...
     * .##
     * ##.
     *
     * */

  } else if (rotate % 2 == 1 && type == I) {
    int coord[] = {5, 2, 5, 1, 5, 0, 5, 3};
    setCoordinates(coordinates, coord);

    /* ..#.
     * ..#.
     * ..#.
     * ..#.
     *
     * */
  } else if (type == I) {
    int coord[] = {3, 0, 4, 0, 5, 0, 6, 0};
    setCoordinates(coordinates, coord);

    /* ....
     * ....
     * ####
     * ....
     *
     * */
  }
}
void get_tetra_four(int coordinates[], int rotate, int type) {
  // TODO если это Т то поднять наверх

  // TODO ПРОВЕРИТЬ на коректность в соответвии со специф tetris rotate system
  if (type == T && rotate == STRAIGHT) {
    int coord[] = {3, 1, 4, 1, 5, 1, 4, 2};
    setCoordinates(coordinates, coord);

    /* ...
     * ###
     * .#.
     *
     * */
  } else if (type == T && rotate == RIGHT) {
    int coord[] = {3, 1, 4, 1, 4, 0, 4, 2};
    setCoordinates(coordinates, coord);

    /* .#.
     * ##.
     * .#.
     *
     * */

  } else if (type == T && rotate == COMPLETE) {
    int coord[] = {3, 1, 4, 1, 5, 1, 4, 0};

    setCoordinates(coordinates, coord);

    /* .#.
     * ###
     * ...
     *
     * */
  } else if (type == T && rotate == REFLEX) {
    int coord[] = {5, 1, 4, 1, 4, 0, 4, 2};
    setCoordinates(coordinates, coord);

    /* .#.
     * .##
     * .#.
     *
     * */
  }

  else if (type == L && rotate == COMPLETE) {
    int coord[] = {3, 1, 4, 1, 5, 1, 5, 0};
    setCoordinates(coordinates, coord);
    /* ..#
     * ###
     * ...
     *
     * */

  } else if (type == L && rotate == RIGHT) {
    int coord[] = {4, 0, 4, 1, 4, 2, 5, 2};
    setCoordinates(coordinates, coord);
    /* .#.
     * .#.
     * .##
     *
     * */

  } else if (type == L && rotate == STRAIGHT) {
    int coord[] = {3, 1, 4, 1, 5, 1, 3, 2};
    setCoordinates(coordinates, coord);
    /*
     * ...
     * ###
     * #..
     *
     * */

  } else if (type == L && rotate == REFLEX) {
    int coord[] = {4, 0, 4, 1, 4, 2, 3, 0};
    setCoordinates(coordinates, coord);
    /* ##.
     * .#.
     * .#.
     *
     * */

  } else if (type == J && rotate == COMPLETE) {
    int coord[] = {3, 1, 4, 1, 5, 1, 3, 0};
    setCoordinates(coordinates, coord);
    /*
     * #..
     * ###
     * ...
     *
     * */

  } else if (type == J && rotate == RIGHT) {
    int coord[] = {4, 0, 4, 1, 4, 2, 5, 0};
    setCoordinates(coordinates, coord);

    /* .##
     * .#.
     * .#.
     *
     * */
  } else if (type == J && rotate == STRAIGHT) {
    int coord[] = {3, 1, 4, 1, 5, 1, 5, 2};
    setCoordinates(coordinates, coord);
    /*
     * ...
     * ###
     * ..#
     *
     * */

  } else if (type == J && rotate == REFLEX) {
    int coord[] = {4, 0, 4, 1, 4, 2, 3, 2};
    setCoordinates(coordinates, coord);

    /* .#.
     * .#.
     * ##.
     *
     * */
  }
}

void get_new_tetraMino(Tetramino* tetraMino) {
  int current = tetraMino->type;
  int next = tetraMino->next_type;

  if (current == 0) {
    current = tetraMino->type = get_random(7);
    tetraMino->next_type = get_random(7);

  } else {
    int tmp = 1;
    int flag = 1;
    while (flag) {
      //      printw("\nfdfdfdfdf");
      tmp = get_random(get_real_len_of_number(tetraMino->meshok.pieses, 7));
      int tmp_q = tetraMino->meshok.pieses[tmp - 1];
      if (tmp_q != 0) {
        tetraMino->next_type = tetraMino->meshok.pieses[tmp - 1];
        current = tetraMino->type = next;
        flag = 0;
        break;
      }
    }
  }
  tetraMino->rotate = COMPLETE;
  tetraMino->center_x = 0;
  tetraMino->center_y = 0;
  null_array(tetraMino->tmp_current_figure_on_field, HEIGHT, WIDTH);
  get_TetraMino(tetraMino->coordinates, tetraMino->rotate, tetraMino->type);
}
--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/src/utilities.c
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */

#include "../inc/utilities.h"

int** malloc_array(int rows, int cols) {
  int** field = malloc(sizeof(int*) * rows);
  for (int i = 0; i < rows; i++) {
    field[i] = calloc(cols, sizeof(int));
  }
  return field;
}
void free_array(int** field, int rows) {
  for (int i = 0; i < rows; i++) {
    if (field[i] != NULL) {
      free(field[i]);
    }
  }
  if (field != NULL) free(field);
}
void null_array(int** field, int rows, int cols) {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      field[i][j] = 0;
    }
  }
}
void bin_array(int** src, int** dist, int rows, int cols) {
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      if (src[i][j] == 0)
        dist[i][j] = 0;
      else
        dist[i][j] = 1;
    }
  }
}
void init_array(int array[], int size) {
  for (int i = 0; i < size; i++) {
    array[i] = 0;
  }
}
// получает длину числа без ведущих нулей
int get_real_len_of_number(const int a[], int size) {
  int i = 0;
  int count = 0;
  for (i = size - 1; i >= 0; i--) {
    if (a[i] == 0) {
      count++;
    } else {
      break;
    }
  }

  return size - count;
}
void print_array(int** array) {
  printf("--------------------\n");

  for (int i = 0; i < HEIGHT; i++) {
    for (int j = 0; j < WIDTH; j++) {
      printf("%d ", array[i][j]);
    }
    printf("\n");
  }
  printf("--------------------\n");
}

int find(const int array[], int size, int i) {
  int res = 0;
  for (int k = 0; k < size; k++) {
    if (array[k] == i) {
      res = k;
      break;
    }
  }
  return res;
}

int get_min(const int a, const int b) { return a > b ? b : a; }

int get_max(const int a, const int b) { return a < b ? b : a; }
--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/src/game_rules.c
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */

#include "../inc/game_rules.h"
int calc_score(int lines) {
  int res = 0;
  if (lines != 0) {
    switch (lines) {
      case 1:
        res = 100;
        break;
      case 2:
        res = 300;
        break;
      case 3:
        res = 700;
        break;
      default:
        res = 1500;
        break;
    }
  }
  return res;
}
int calc_level(int current_score) {
  int res = current_score / 600;
  return res > 10 ? 10 : res;
}
--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/src/game_state_management.c
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */
#include "../inc/game_state_management.h"
GameInfo_t init_empty_gameInfo() {
  GameInfo_t gameInfo = {0};
  gameInfo.score = 0;
  gameInfo.high_score = 0;
  gameInfo.level = 0;
  gameInfo.pause = 0;
  gameInfo.speed = 0;
  gameInfo.field = malloc_array(HEIGHT, WIDTH);
  gameInfo.next = malloc_array(NEXT_FIELD, NEXT_FIELD);
  return gameInfo;
}
int next_to_field(int** next, int** field) {
  int is_all_ok_val = is_all_ok_func(field, next);
  if (is_all_ok_val) {
    for (int i = 0; i < HEIGHT; i++) {
      for (int j = 0; j < WIDTH; j++) {
        int n_tmp = next[i][j];
        int f_tmp = field[i][j];
        int res = n_tmp + f_tmp;
        field[i][j] = res;
      }
    }
  }
  return is_all_ok_val;
}
int check_collision(Tetramino tetraMino, int** field) {
  int is_all_ok_val = MY_OK;
  for (int i = 0; i < 8; i += 2) {
    int x = tetraMino.coordinates[i] + tetraMino.center_x;
    int y = tetraMino.coordinates[i + 1] + tetraMino.center_y;
    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) {
      is_all_ok_val = ERROR;
      break;
    }
  }
  if (is_all_ok_val == MY_OK) {
    int** tmp_next = malloc_array(HEIGHT, WIDTH);
    tetra_to_array(tetraMino, tmp_next);
    is_all_ok_val = is_all_ok_func(field, tmp_next);
    free_array(tmp_next, HEIGHT);
  }
  return is_all_ok_val;
}
int is_all_ok_func(int** field, int** next) {
  int** tmp_next = malloc_array(HEIGHT, WIDTH);

  int** tmp_field = malloc_array(HEIGHT, WIDTH);
  bin_array(next, tmp_next, HEIGHT, WIDTH);

  bin_array(field, tmp_field, HEIGHT, WIDTH);
  int is_all_ok_val = MY_OK;

  for (int i = 0; i < HEIGHT; i++) {
    for (int j = 0; j < WIDTH; j++) {
      int n_tmp = tmp_next[i][j];
      int f_tmp = tmp_field[i][j];
      int res = n_tmp + f_tmp;
      if (res > 1) {
        is_all_ok_val = ERROR;
        break;
      }
    }
    if (is_all_ok_val == ERROR) break;
  }
  free_array(tmp_field, HEIGHT);
  free_array(tmp_next, HEIGHT);

  return is_all_ok_val;
}

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/src/tetramino_movement.c
Contents:
/*
 * @author Azamat G.
 * @date 14.08.2025.
 * @details
 *
 */

#include "../inc/tetramino_movement.h"

int can_i_move(Tetramino tetraMino, int** field, UserAction_t key) {
  int** next = malloc_array(HEIGHT, WIDTH);
  int** tmp_next = malloc_array(HEIGHT, WIDTH);

  int** tmp_field = malloc_array(HEIGHT, WIDTH);
  tetra_to_array(tetraMino, next);
  move_tetraMino(&tetraMino, key);
  tetra_to_array(tetraMino, next);

  bin_array(next, tmp_next, HEIGHT, WIDTH);

  bin_array(field, tmp_field, HEIGHT, WIDTH);
  int is_all_ok_val = is_all_ok_func(tmp_field, tmp_next);
  free_array(tmp_next, HEIGHT);
  free_array(tmp_field, HEIGHT);
  free_array(next, HEIGHT);

  return is_all_ok_val;
}
int is_rotate_possible(Tetramino tetraMino, int rotate) {
  int possible = 1;
  tetraMino.rotate = rotate;
  get_TetraMino(tetraMino.coordinates, tetraMino.rotate, tetraMino.type);
  for (int i = 0; i < 8; i += 2) {
    int x = tetraMino.coordinates[i] + tetraMino.center_x;
    int y = tetraMino.coordinates[i + 1] + tetraMino.center_y;
    if (x < 0 || x >= WIDTH || y >= HEIGHT || y < 0) {
      possible = 0;
      break;
    }
  }
  return possible;
}
int is_it_movement(UserAction_t userAction) {
  int res = MY_OK;
  if (!(userAction == Left || userAction == Right || userAction == Action))
    res = ERROR;
  return res;
}
int is_it_down_mv(UserAction_t userAction) {
  int res = MY_OK;
  if (userAction == Down) {
    res = ERROR;
  }
  return res;
}

void move_tetraMino(Tetramino* tetraMino, UserAction_t key) {
  // TODO уменьшить размер строк

  int min_x =
      get_min(get_min(tetraMino->coordinates[0], tetraMino->coordinates[2]),
              get_min(tetraMino->coordinates[4], tetraMino->coordinates[6])) +
      tetraMino->center_x;

  int max_x =
      get_max(get_max(tetraMino->coordinates[0], tetraMino->coordinates[2]),
              get_max(tetraMino->coordinates[4], tetraMino->coordinates[6])) +
      tetraMino->center_x;
  switch (key) {
    case Left:
      if ((min_x - 1) >= 0) tetraMino->center_x -= 1;
      break;

    case Right:
      if ((max_x + 1 < WIDTH)) tetraMino->center_x += 1;
      break;
    case Action:
      rotate_TetraMino(tetraMino);
      break;
    default:
      break;
  }
}

void move_down_tetraMino(Tetramino* tetraMino) { tetraMino->center_y += 1; }

void move_up_tetraMino(Tetramino* tetraMino) {
  if (tetraMino->center_y >= HEIGHT - 1) tetraMino->center_y -= 1;
}
void rotate_TetraMino(Tetramino* tetraMino) {
  int rotate = (tetraMino->rotate + 1) % 4;

  if (is_rotate_possible(*tetraMino, rotate)) {
    tetraMino->rotate = rotate;
    get_TetraMino(tetraMino->coordinates, tetraMino->rotate, tetraMino->type);
  }
}
--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/src/field_mechanics.c
Contents:
/*
 * @author Azamat G.
 * @date 14.08.2025.
 * @details
 *
 */

#include "../inc/field_mechanics.h"

int scan(int** field, int rows, int cols) {
  int count = 0;
  int full_scan = 0;
  while (full_scan != 2) {
    int flag = 1;
    for (int i = rows - 1; i >= 0; i--) {
      int destroy = to_be_destroyed(field[i], cols);
      if (destroy == YES) {
        destruction(field, cols, i);
        count++;
        flag = 0;
      }
    }
    if (flag == 1) full_scan++;
  }
  return count;
}
int to_be_destroyed(const int a[], int size) {
  int sum = 0;
  for (int i = 0; i < size; i++) {
    if (a[i] != 0) sum++;
  }
  return sum == size ? YES : NO;
}
void destruction(int** field, int cols, int row_not) {
  for (int i = 0; i < cols; i++) {
    field[row_not][i] = 0;
  }
  for (int j = 0; j < cols; j++) {
    for (int i = row_not; i > 0; i--) {
      //        int tmp_a = field[i][j];
      int tmp_b = field[i - 1][j];
      field[i][j] = tmp_b;
    }
  }
}

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/inc/storage.h
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */

#ifndef STORAGE_H
#define STORAGE_H
#include "../tetris_engine.h"
/**
 * @brief Получает рекорд из файла.
 *
 * @return Текущий рекорд (0 если файл недоступен).
 *
 * @note Файл: "highscore.txt" в рабочей директории.
 */
int get_highScore();
/**
 * @brief Записывает новый рекорд в файл.
 *
 * @param h_score Новое значение рекорда.
 *
 * @note Файл: "highscore.txt" в рабочей директории.
 */
void write_high_score(int h_score);
#endif  // STORAGE_H

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/inc/tetramino_movement.h
Contents:
/*
 * @author Azamat G.
 * @date 14.08.2025.
 * @details
 *
 */

#ifndef TETRAMINO_MOVEMENT_H
#define TETRAMINO_MOVEMENT_H
#include "../../../brick_game.h"
#include "../tetris_engine.h"
/**
 * @brief Проверяет возможность движения фигуры.
 *
 * @param tetraMino Фигура.
 * @param field Игровое поле.
 * @param key Направление (Left/Right/Action).
 * @return 1 если возможно, иначе 0.
 */
int can_i_move(Tetramino tetraMino, int **field, UserAction_t key);

/**
 * @brief Проверяет возможность поворота.
 *
 * @param tetraMino Фигура.
 * @param rotate Угол поворота (0-3).
 * @return 1 если возможно, иначе 0.
 */
int is_rotate_possible(Tetramino tetraMino, int rotate);
/**
 * @brief Двигает фигуру.
 *
 * @param tetraMino Указатель на фигуру.
 * @param key Направление (Left/Right/Action).
 */
// Аналогично для:
void move_tetraMino(Tetramino *tetraMino, UserAction_t key);
void move_down_tetraMino(Tetramino *tetraMino);
void move_up_tetraMino(Tetramino *tetraMino);
void rotate_TetraMino(Tetramino *tetraMino);
/**
 * @brief Проверяет, является ли действие движением.
 *
 * @param userAction Действие.
 * @return 1 если да, иначе 0.
 */
int is_it_movement(UserAction_t userAction);
/**
 * @brief Проверяет, является ли действие движением вниз.
 *
 * @param userAction Действие.
 * @return 1 если нет, 0 если Down.
 */
int is_it_down_mv(UserAction_t userAction);

#endif  // TETRAMINO_MOVEMENT_H

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/inc/field_mechanics.h
Contents:
/*
 * @author Azamat G.
 * @date 14.08.2025.
 * @details
 *
 */

#ifndef TETRIS_MECHANICS_H
#define TETRIS_MECHANICS_H
#include "../tetris_engine.h"
/**
 * @brief Сканирует поле на заполненные строки.
 *
 * @param field Игровое поле.
 * @param rows Число строк.
 * @param cols Число столбцов.
 * @return Количество удаленных строк.
 *
 * @details Удаляет строки и сдвигает поле вниз.
 */
int scan(int **field, int rows, int cols);
/**
 * @brief Проверяет, заполнена ли строка.
 *
 * @param a Строка поля.
 * @param size Длина строки.
 * @return 1 (YES) если заполнена, иначе 0.
 */
int to_be_destroyed(const int a[], int size);
/**
 * @brief Удаляет строку и сдвигает поле.
 *
 * @param field Игровое поле.
 * @param cols Число столбцов.
 * @param row_not Индекс удаляемой строки.
 */
void destruction(int **field, int cols, int row_not);

#endif  // TETRIS_MECHANICS_H

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/inc/defines.h
Contents:
#ifndef BRICK_GAME_DEFINES_H_
#define BRICK_GAME_DEFINES_H_
#include "../tetris_engine.h"
enum answer { YES, NO };
/** Статусы функций. */
enum status { ERROR, MY_OK };

/** Типы фигур. */
enum figures { T = 1, J, L, I, S, Z, O };

/** Углы поворота фигур. */
enum degrees { COMPLETE, RIGHT, STRAIGHT, REFLEX };

/** Нет действия. */
#define NONE_ACTION 8

/** Высота игрового поля. */
#define HEIGHT 20

/** Ширина игрового поля. */
#define WIDTH 10

/** Масштаб отрисовки по X. */
#define scale_field 2

/** Общий масштаб. */
#define scale 2

/** Высота окна поля. */
#define FIELD_Y HEIGHT + 2

/** Ширина окна поля. */
#define FIELD_X WIDTH* scale_field + 2

/** Размер окна для следующей фигуры. */
#define NEXT_FIELD 10

/** Размер окна информации. */
#define INFO_FIELD 10

/** Ширина окна информации. */
#define INFO_X INFO_FIELD* scale + 2

/** Высота окна информации. */
#define INFO_Y INFO_FIELD + 2

/** Ширина окна следующей фигуры. */
#define NEXT_X NEXT_FIELD* scale + 2

/** Высота окна следующей фигуры. */
#define NEXT_Y NEXT_FIELD

/** Время задержки в микросекундах. */
#define TIME 2000000

/** Код клавиши Escape. */
#define ESCAPE 27

/** Код клавиши Enter. */
#define ENTER_KEY 10

/** Код клавиши пробела. */
#define SPACE 32

#endif
--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/inc/TGM3Randomizer.h
Contents:
/*
 * @author Azamat G.
 * @date 12.08.2025.
 * @details
 *
 */

#ifndef TGM3RANDOMIZER_H
#define TGM3RANDOMIZER_H
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "../tetris_engine.h"

typedef struct {
  const char *pieces[7];
  const char *pool[35];
  const char *order[7];
  int order_size;
  const char *history[4];
} TGM3Randomizer;
/**
 * @brief Инициализация генератора TGM3
 *
 * @param r Указатель на структуру генератора
 */
void init_randomizer(TGM3Randomizer *r);

/**
 * @brief Получить следующую фигуру
 *
 * @param r Указатель на структуру генератора
 * @return const char* Символ фигуры ("I", "J", "L", "O", "S", "T", "Z")
 */
const char *next_piece(TGM3Randomizer *r);

/**
 * @brief Проверяет, содержится ли элемент в массиве
 *
 * @param arr Массив строк
 * @param size Размер массива
 * @param value Строка для поиска
 * @return 1 — найдено, 0 — нет
 */
int contains(const char *arr[], int size, const char *value);

/**
 * @brief Ищет индекс элемента в массиве
 *
 * @param arr Массив строк
 * @param size Размер массива
 * @param value Строка для поиска
 * @return Индекс или -1, если не найдено
 */
int index_of(const char *arr[], int size, const char *value);
#endif  // TGM3RANDOMIZER_H

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/inc/utilities.h
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */

#ifndef UTILITIES_H
#define UTILITIES_H
#include "../tetris_engine.h"
/**
 * @brief Выделяет память под 2D-массив.
 *
 * @param rows Строки.
 * @param cols Столбцы.
 * @return Указатель на массив.
 */
int **malloc_array(int rows, int cols);
/**
 * @brief Освобождает 2D-массив.
 *
 * @param field Массив.
 * @param rows Строки.
 */
void free_array(int **field, int rows);

/**
 * @brief Сортирует массив по убыванию пузырьковой сортировкой.
 *
 * @param array Целевой массив.
 * @param size Размер массива.
 */
// void sort(int array[], int size);

/**
 * @brief Заполняет 2D-массив нулями.
 *
 * @param field Целевой массив.
 * @param rows Число строк.
 * @param cols Число столбцов.
 */
void null_array(int **field, int rows, int cols);
/**
 * @brief Бинаризует массив (0 → 0, !0 → 1).
 *
 * @param src Исходный массив.
 * @param dist Целевой массив.
 * @param rows Число строк.
 * @param cols Число столбцов.
 */
void bin_array(int **src, int **dist, int rows, int cols);
/**
 * @brief Заполняет массив нулями.
 *
 * @param array Целевой массив.
 * @param size Размер массива.
 */
void init_array(int array[], int size);
/**
 * @brief Вычисляет значимую длину массива (без завершающих нулей).
 *
 * @param a Целевой массив.
 * @param size Физический размер массива.
 * @return Число значимых элементов.
 */
int get_real_len_of_number(const int a[], int size);

/**
 * @brief Выводит 2D-массив в stdout.
 *
 * @param array Целевой массив.
 *
 * @note Для отладки, формат:
 *   --------------------
 *   0 0 1 0 ...
 *   1 0 0 1 ...
 *   --------------------
 */
void print_array(int **array);

/**
 * @brief Возвращает минимальное из двух чисел.
 *
 * @param a Первое число.
 * @param b Второе число.
 * @return Меньшее из a и b.
 */
int get_min(int a, int b);
/**
 * @brief Возвращает максимальное из двух чисел.
 *
 * @param a Первое число.
 * @param b Второе число.
 * @return Большее из a и b.
 */
int get_max(int a, int b);

/**
 * @brief Ищет первое вхождение элемента в массиве.
 *
 * @param array Целевой массив.
 * @param size Размер массива.
 * @param i Искомое значение.
 * @return Индекс первого вхождения или -1 если не найдено.
 */
int find(const int array[], int size, int i);
#endif  // UTILITIES_H

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/inc/game_state_management.h
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */

#ifndef GAME_STATE_MANAGEMENT_H
#define GAME_STATE_MANAGEMENT_H
#include "../../../brick_game.h"
#include "../tetris_engine.h"
GameInfo_t init_empty_gameInfo();
/**
 * @brief Объединяет поле с фигурой.
 *
 * @param next Массив фигуры.
 * @param field Игровое поле.
 * @return 1 (MY_OK) если объединение успешно, 0 (ERROR) при коллизии.
 */
int next_to_field(int **next, int **field);
/**
 * @brief Проверяет коллизию фигуры с игровым полем.
 *
 * @param tetraMino Фигура для проверки.
 * @param field Игровое поле.
 * @return 1 (MY_OK) если коллизий нет, 0 (ERROR) при коллизии.
 */
int check_collision(Tetramino tetraMino, int **field);
/**
 * @brief Проверяет коллизию поля и фигуры.
 *
 * @param field Игровое поле.
 * @param next Фигура.
 * @return 1 если коллизии нет, иначе 0.
 */
int is_all_ok_func(int **field, int **next);
#endif  // GAME_STATE_MANAGEMENT_H

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/inc/game_rules.h
Contents:
/*
 * @author Azamat G.
 * @date 15.08.2025.
 * @details
 *
 */

#ifndef GAME_RULES_H
#define GAME_RULES_H
#include "../tetris_engine.h"
/**
 * @brief Вычисляет очки за удаленные строки.
 *
 * @param lines Число строк.
 * @return Количество очков.
 */
int calc_score(int lines);
/**
 * @brief Вычисляет текущий уровень игры на основе счета.
 *
 * @param current_score Текущий счет игрока.
 * @return Текущий уровень (0-10).
 *
 * @details Формула: level = current_score / 600, максимум 10.
 */
int calc_level(int current_score);
#endif  // GAME_RULES_H

--------------------------------------------------

Path: ../tsc/src/brick_game/tetris/tetris_engine/inc/tetramino.h
Contents:
#ifndef OBJECTS_H_
#define OBJECTS_H_

#include "../tetris_engine.h"

/**
 * @brief Структура тетрамино.
 *
 * @field type Текущий тип фигуры.
 * @field next_type Следующий тип.
 * @field rotate Угол поворота.
 * @field center_x X-центр фигуры.
 * @field center_y Y-центр фигуры.
 * @field coordinates Координаты блоков (относительно центра).
 * @field tmp_current_figure_on_field Временное поле для отрисовки.
 */
typedef struct {
  int type;
  int next_type;
  int rotate;
  int center_x;
  int center_y;
  int coordinates[8];
  int **tmp_current_figure_on_field;
} Tetramino;
/**
 * @brief Создает пустую фигуру.
 *
 * @return Инициализированная структура Tetramino.
 */
Tetramino init_empty_tetraMino();

/**
 * @brief Преобразует фигуру в 2D-массив.
 *
 * @param tetraMino Фигура.
 * @param next Целевой массив.
 */
void tetra_to_array(Tetramino tetraMino, int **next);
/**
 * @brief Копирует координаты фигуры.
 *
 * @param coordinates Целевой массив.
 * @param values Исходные координаты.
 */
void setCoordinates(int *coordinates, const int *values);
/**
 * @brief Генерирует координаты фигуры по типу и углу.
 *
 * @param coordinates Целевой массив.
 * @param rotate Угол поворота.
 * @param type Тип фигуры (T, J, L, I, S, Z, O).
 */
void get_TetraMino(int coordinates[], int rotate, int type);
/**
 * @brief Генерирует координаты фигуры по типу и углу.
 *
 * @param coordinates Целевой массив.
 * @param rotate Угол поворота.
 * @param type Тип фигуры (T, J, L, I, S, Z, O).
 */
void get_tetra_two(int coordinates[], int rotate, int type);
/**
 * @brief Генерирует координаты фигуры по типу и углу.
 *
 * @param coordinates Целевой массив.
 * @param rotate Угол поворота.
 * @param type Тип фигуры (T, J, L, I, S, Z, O).
 */
void get_tetra_four(int coordinates[], int rotate, int type);

/**
 * @brief Создает новую фигуру.
 *
 * @param tetraMino Указатель на фигуру.
 *
 * @details Использует TGM3Randomizer для генерации.
 */
void get_new_tetraMino(Tetramino *tetraMino);

#endif  // OBJECTS_H_
--------------------------------------------------

