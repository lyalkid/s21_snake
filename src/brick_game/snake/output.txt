Path: ./main.cpp
Contents:
/*
* @author Azamat G. 
* @date 21.09.2025.
* @details
*
*/
#include "controller/controller.h"
#include "model/Snake.h"


extern "C" {
#include "../../gui/cli/cli.h"
#include "../../gui/cli/tetris/frontend.h"
#include "../brick_game.h"
#include "../utils/timer.h"
}

using namespace s21;
const char *actionToString(UserAction_t s) {
    switch (s) {
        case Start:
            return "start      ";
            break;
        case Pause:
            return "pause      ";
            break;
        case Terminate:
            return "terminate  ";
            break;
        case Left:
            return "left       ";
            break;
        case Right:
            return "right      ";
            break;
        case Up:
            return "up         ";
            break;
        case Down:
            return "down       ";
        case Action:
            return "action     ";
    }
    return "none_action";
}
void debug_info(UserAction_t action, Vec2 dir, Vec2 head, bool shift, Vec2 body[], int score) {
    mvprintw(25, 13, "action: %s", actionToString(action));
    mvprintw(26, 13, "dir:   ,   ");
    mvprintw(26, 13, "dir: %d, %d", dir.x, dir.y);
    mvprintw(27, 13, "head:   ,   ");
    mvprintw(27, 13, "head: %d, %d", head.x, head.y);
    if (shift) {
        mvprintw(28, 13, "time to shift!");
    }
    else {
        mvprintw(28, 13, "              ");

    }
    for (int i = 0; i < score; i++) {
        mvprintw(29+i, 13, "body[%d]: %d, %d", i, body[i].x, body[i].y);
    }
}

void draw_snake(WINDOW* win, int **field) {
    werase(win);

    for (int i = 0; i < HEIGHT; i++) {
        for (int j = 0; j < WIDTH; j++) {
            int res = field[i][j];
            if ((res != 0 && field[i][j] == 0) || field[i][j] != 0) {
                wattron(win, COLOR_PAIR(res));

                mvwprintw(win, i + 1, j * scale_field + 1, "[]");

                wattroff(win, COLOR_PAIR(res));
            } else {
                mvwprintw(win, i + 1, j * scale_field + 1, "  ");
            }
        }
    }

    box(win, 0, 0);
    wrefresh(win);
    refresh();
}


int main() {
    init_nc();
    WINDOW *win = newwin(FIELD_Y, FIELD_X, 0, 0);
    Snake snake{};
    Controller controller(&snake);
    while (true) {
        UserAction_t action = getSignal(getch());
        debug_info(action, controller.get_model().getDirection(), controller.get_model().getHead(), controller.timer.time_to_shift, controller.get_model().getBody(), controller.get_model().getScore());
        if (action == Terminate) break;
        controller.userInput(action, true);
        if (controller.get_paused()) {
            while (controller.get_paused()) {
                controller.userInput(getSignal(getch()), true);
            }
        }
        // out(controller.get_game_info().field );
        draw_snake(win, controller.updateCurrentState().field);
        // out(controller.get_game_info().field );

        // usleep(1250000);
        countTime(&controller.timer);

    }
}

--------------------------------------------------

Path: ./output.txt
Contents:

--------------------------------------------------

Path: ./controller/controller.h
Contents:
/*
* @author Azamat G. 
* @date 20.09.2025.
* @details
*
*/

#ifndef CONTROLLER_H
#define CONTROLLER_H
#include <unistd.h>

extern "C" {
#include "../../brick_game.h"
#include "../../utils/timer.h"
}

#include  "../model/Snake.h"
#define BERRY 1
#define HEAD 2
#define SNAKE 3
namespace s21 {
    /**
     *@param bool paused ;
     *@param bool active ;
     *@param GameInfo_t info;
     *@param Snake* model;
     */
    class Controller {
    public:
        Controller(Snake *snake);

        ~Controller() = default;

        bool get_active() { return active; }
        bool get_paused() { return paused; }
        Snake get_model(){return *model;}
        GameInfo_t get_game_info();

        void userInput(UserAction_t action, bool hold);

        GameInfo_t updateCurrentState();

    private:
        bool paused;
        bool active;
        // UserAction_t current_action;
        GameInfo_t info{};
        Snake *model;
    public:        Shift_timer timer{};
    };
}
#endif //CONTROLLER_H

--------------------------------------------------

Path: ./controller/controller.cpp
Contents:
/*
* @author Azamat G. 
* @date 20.09.2025.
* @details
*
*/
#include  "controller.h"

extern "C" {
#include  "../../utils/utilities.h"
}

namespace s21 {
    Controller::Controller(s21::Snake *snake) : paused(false), active(false), model(snake) {
        info = init_empty_gameInfo();
        null_array(info.field, HEIGHT, WIDTH);
        timer = init_shift_timer();
        // model->update(info.field);
    }
    GameInfo_t Controller::get_game_info() {
        return info;
    }


    GameInfo_t Controller::updateCurrentState() {
        if (timer.time_to_shift) {
            model->update(info.field);
            timer.time_to_shift = false;
            get_time(&timer.before);
        }
        int size = model->score;
        null_array(info.field, HEIGHT, WIDTH);
        for (int i = 0; i < size; i++) {
            const int x = model->body[i].x;
            const int y = model->body[i].y;
            if ((x >= 0 && x < WIDTH) && (y >= 0 && y < HEIGHT)) {
                if (i == 0) {
                    info.field[y][x] = HEAD;
                }
                else info.field[y][x] = SNAKE;
            }
        }
        info.field[model->berry.y][model->berry.x] = BERRY;
        // if (active && !paused ) {

        // if (){model->update();}
        // }


        // if (active && !paused) {
        //     model->update();
        //     if (model->checkCollision()) {
        //         active = false;
        //     }
        // }
        //
        // info.score = model->getScore();
        // info.high_score = 0;
        // info.level = 1;
        // info.speed = 1;
        // info.pause = paused ? 1 : 0;

        // // создаём поле
        // int w = model->width;
        // int h = model->height;
        // int** field = (int**)malloc(sizeof(int*) * h);
        // for (int y = 0; y < h; y++) {
        //     field[y] = (int*)calloc(w, sizeof(int));
        // }
        //
        // // ягода
        // auto berry = model->getBerry();
        // field[berry.y][berry.x] = 2; // ягода
        //
        // // змейка
        // auto segments = model->getSegments();
        // for (size_t i = 0; i < segments.size(); i++) {
        //     int code = (i == 0) ? 3 : 1; // 3 = голова, 1 = тело
        //     field[segments[i].y][segments[i].x] = code;
        // }
        //
        // info.field = field;
        // info.next = nullptr;

        return info;
    }

    void Controller::userInput(UserAction_t action, bool hold) {
        switch (action) {
            case Start:
                active = true;
                paused = false;
                model->reset();
                break;

            case Pause:
                paused = !paused;
                break;

            case Terminate:
                active = false;
                break;

            case Left: model->changeDirection(Left);
                break;
            case Right: model->changeDirection(Right);
                break;
            case Up: model->changeDirection(Up);
                break;
            case Down: model->changeDirection(Down);
                break;
            case Action: model->update(info.field);
                break;
            default: break;
        }
        if (model->direction_changed) {
            model->update(info.field);
            model->direction_changed = false;
            timer.time_to_shift = false;
            get_time(&timer.before);
        }

        if (hold)hold = false;
        else hold = true;
    }
}

--------------------------------------------------

Path: ./model/Snake.cpp
Contents:
/*
* @author Azamat G.
* @date 13.09.2025.
* @details
*
*/

#include  "Snake.h"


namespace s21 {
    Snake::Snake() {
        width = WIDTH;
        height = HEIGHT;
        reset();
    }

    void Snake::reset() {
        int startX = 5, startY = 0;
        head = {startX, startY};
        score = 4;
        dir = {1, 0};
        direction_changed = false;
        for (int i = 0; i < score; i++) {
            body[i] = {startX - i, startY};  // голова справа, хвост слева
        }
        spawn_berry();
    }

    void Snake::changeDirection(UserAction_t action) {
        Vec2 tmp = dir;
        if (action == Left && dir.x != 1) {
            dir.x = -1;
            dir.y = 0;
        }
        if (action == Right && dir.x != -1) {
            dir.x = +1;
            dir.y = 0;
        }
        if (action == Down && dir.y != -1) {
            dir.x = 0;
            dir.y = +1;
        }
        if (action == Up && dir.y != 1) {
            dir.x = 0;
            dir.y = -1;
        }
        if (tmp.x != dir.x || tmp.y != dir.y) {
            direction_changed = true;
        }
    }

    void Snake::update(int **field) {
        for (int i = score; i >= 0; i--) {
            body[i] = body[i - 1];
        }
        body[0] = head;

        head.x += dir.x;
        if (head.x < 0) head.x += 1;
        else if (head.x >= width) head.x -= 1;
        head.y += dir.y;
        if (head.y < 0) head.y += 1;
        else if (head.y >= height) head.y -= 1;
        if (head.x == berry.x && head.y == berry.y) {
            score++;

            while (true){
                berry.x = rand() % width;
                berry.y = rand() % height;
                if (field[berry.y][berry.x] == 0) break;
            }
        }
    }


    void Snake::spawn_berry() {
        berry = {rand() % width, rand() % height};
    }
}

--------------------------------------------------

Path: ./model/Snake.h
Contents:
/*
* @author Azamat G.
* @date 13.09.2025.
* @details
*
*/

#ifndef SNAKE_H
#define SNAKE_H

extern "C"
{
#include "../../brick_game.h"
#include "../../utils/defines.h"
}


#include  <stdlib.h>
#include  <vector>
namespace s21 {
    typedef struct {
        int x;
        int y;
    }Vec2;

    class Snake {
    public:
        friend class Controller;
        Snake();
        void reset();
        void changeDirection(UserAction_t action);
        void update(int **field);

        Vec2 getDirection(){return dir;}
        Vec2 getHead(){return head;}
        Vec2 *getBody(){return body;}
        int getScore(){return score;}
        ~Snake() = default;
    private:
        int width;
        int height;
        int score;
        Vec2 body[200];
        Vec2 head;
        Vec2 berry;
        Vec2 dir;
        bool direction_changed;
        void spawn_berry();
    };
}
#endif //SNAKE_H

--------------------------------------------------

